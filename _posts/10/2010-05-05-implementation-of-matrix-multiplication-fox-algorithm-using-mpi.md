--- 
layout: post
title: Implementation of matrix multiplication fox algorithm using MPI
published: true
meta: {}

tags: 
- Coding
- IT
- MPI
- parallel
type: post
status: publish
---
<a class="tt-flickr tt-flickr-Square" title="Power" href="http://www.flickr.com/photos/boilermatt/4578284881/"><img class="alignnone" src="http://farm5.static.flickr.com/4016/4578284881_3cbe155aa6_s.jpg" alt="Power" height="1" width="1" /></a> Software?efficiency??always improves a lot by parallelizing. Here is an implementation of fox algorithm, which is one of the algorithms calculating matrix multiplication, using MPI.<blockquote><strong><a title="MPI" href="http://en.wikipedia.org/wiki/Message_Passing_Interface" target="_blank">Message Passing Interface</a></strong><a title="MPI" href="http://en.wikipedia.org/wiki/Message_Passing_Interface" target="_blank"> (</a><strong><a title="MPI" href="http://en.wikipedia.org/wiki/Message_Passing_Interface" target="_blank">MPI</a></strong><a title="MPI" href="http://en.wikipedia.org/wiki/Message_Passing_Interface" target="_blank">)</a> is a specification for an?API that allows many computers to communicate with one another.</blockquote><p>MPI is an parallel library to help programming. Its main idea is?transferring messages between processes, which are paralleling running in different cores or even CPUs.About fox algorithm, I?recommend everyone read this <a title="fox algorithm" href="http://facultyfp.salisbury.edu/taanastasio/COSC490/Fall03/Lectures/FoxMM/example.pdf" target="_blank">pdf file</a>.Here is my code.</p><p><pre class='c' >#include <stdio.h>#include <stdlib.h>#include <math.h>#include <string.h>#include "mpi.h"#define FRAND frand(1, 100)#define frand(xmin, xmax) ( (double)xmin + (double)(xmax-xmin) * rand()/(double)RAND_MAX)#define ROOT(ANY) if(rank==0){ANY}#define PRINT(M, R, C, MSG) if(rank==0 && v==1){printf("%sn", MSG); print_matrix(M, R, C);}void matrix_multiply(double*, double*, double*, int, int, int);void rearrange(double*, double*, int, int, int, int, int);void print_matrix(double*, int, int);void usage(){     printf("fox [-n x] [-v]n-n x Set matrix size to x.n-v Give detail ouput.nIf no arguments offered, n is set to 4 and there is no output except time consumed.n");}int main(int argc, char *argv[]){    int v = 0;    int n = 4;    int i, j, k;    int size, rank, row_rank, col_rank, grid_rank, root;    int row, col, matrix_row, matrix_col, matrix_size;    int coords[2], reorder = 1, ndim = 2, dims[2] = {0, 0}, periods[2] = {0, 0};    MPI_Comm proc_grid, proc_row, proc_col;    MPI_Status stat;    MPI_Request request_send, request_recv;    double t_all_start, t_algorithm_start;    // Matrix in every processes    double *A;    double *B;    double *C;    double *TA;    double *TB;           // Whole matrix, only rank 0 use these variables    double *temp;    double *matrix_a;    double *matrix_b;    double *result;    // timer    t_all_start = MPI_Wtime();          // MPI Init    MPI_Init(&argc, &argv);    MPI_Comm_size(MPI_COMM_WORLD, &size);    MPI_Comm_rank(MPI_COMM_WORLD, &rank);    // Check input and get big matrix size    for (i = 1; i < argc; i++) {        if(strcmp(argv[i], "-n") == 0) n = atoi(argv[++i]);        else if(strcmp(argv[i], "-v") == 0) v = 1;         else {            ROOT( usage(); )            MPI_Finalize();            return 1;        }    }    MPI_Dims_create(size, ndim, dims);    MPI_Cart_create(MPI_COMM_WORLD, ndim, dims, periods, reorder, &proc_grid);    MPI_Comm_rank(proc_grid, &grid_rank);    MPI_Cart_coords(proc_grid, grid_rank, ndim, coords);    MPI_Comm_split(proc_grid, coords[0], coords[1], &proc_row);    MPI_Comm_split(proc_grid, coords[1], coords[0], &proc_col);    MPI_Comm_rank(proc_row, &col_rank);    MPI_Comm_rank(proc_col, &row_rank);    //printf("Rank %d Row_Rank %d Col_Rank %d Grid_Rank %dn", rank, row_rank, col_rank, grid_rank);    row = dims[0];    col = dims[1];     matrix_row = n / row;    matrix_col = n / col;    matrix_size = matrix_row * matrix_col;    A = (double *) malloc( matrix_size * sizeof(double) );    B = (double *) malloc( matrix_size * sizeof(double) );    C = (double *) malloc( matrix_size * sizeof(double) );    TA = (double *) malloc( matrix_size * sizeof(double) );    TB = (double *) malloc( matrix_size * sizeof(double) );    // rank 0 generate whole matrix    if(rank == 0) {            matrix_a = (double *) malloc( n * n * sizeof(double) );        matrix_b = (double *) malloc( n * n * sizeof(double) );        temp = (double *) malloc( n * n * sizeof(double) );        result = (double *)malloc(n * n * sizeof(double));        for (i = 0; i < n * n; i++) {            matrix_a[i] = FRAND;            matrix_b[i] = FRAND;        }    }    PRINT(matrix_a, n, n, "Matrix A")    PRINT(matrix_b, n, n, "Matrix B")    // rearrange a and b for scattering, then scatter    ROOT( rearrange(temp, matrix_a, row, col, matrix_row, matrix_col, 0); )    MPI_Scatter(temp, matrix_size, MPI_DOUBLE, A, matrix_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);    ROOT( free(matrix_a); )    //PRINT(temp, n, n, "TEMP");    ROOT( rearrange(temp, matrix_b, row, col, matrix_row, matrix_col, 0); )    MPI_Scatter(temp, matrix_size, MPI_DOUBLE, B, matrix_size, MPI_DOUBLE, 0, MPI_COMM_WORLD);    ROOT( free(matrix_b); )    //printf("Scatter finishn");    // algorithm timer start    t_algorithm_start = MPI_Wtime();    // fox algorithm    for (i = 0; i < row; i++) {        // non-blocking send and recv        MPI_Isend(B, matrix_size, MPI_DOUBLE, (row_rank - 1 + row) % row, 111, proc_col, &request_send);         MPI_Irecv(TB, matrix_size, MPI_DOUBLE, (row_rank + 1) % row, 111, proc_col, &request_recv);        root = (row_rank + i) % col;                if ( root == col_rank) {            memcpy( TA, A, matrix_size * sizeof(double) );        }        // broadcast to all processes in the row        MPI_Bcast(TA, matrix_size, MPI_DOUBLE, root, proc_row);        // matrix multiply        matrix_multiply(TA, B, C, matrix_row, matrix_col, matrix_row);                   MPI_Wait(&request_send, &stat);           MPI_Wait(&request_recv, &stat);        memcpy( B, TB, matrix_size * sizeof(double) );    }    //printf("fox finishn");    ROOT( printf("Fox algorithm time %lfn", MPI_Wtime() - t_algorithm_start); )    // gather result from every processes    MPI_Gather(C, matrix_size, MPI_DOUBLE, temp, matrix_size, MPI_DOUBLE, 0, proc_grid);    // rearrange whole matrix for printing right    ROOT( rearrange(result, temp, row, col, matrix_row, matrix_col, 1); )    PRINT(result, n, n, "Result")    ROOT( printf("All time %lfn", MPI_Wtime() - t_all_start); )    // clean up    free(A);    free(B);    free(C);    free(TA);    free(TB);    MPI_Comm_free(&proc_grid);    MPI_Comm_free(&proc_row);    MPI_Comm_free(&proc_col);    MPI_Finalize();    return 0;}void matrix_multiply(double* A, double* B, double* C, int row, int col, int m){    int i, j, k;    for (i = 0; i < row; i++) {        for (j = 0; j < col; j++) {            for (k = 0; k < m; k++) {                C[i*col + j] += A[i*m + k] * B[k*col +j];                }        }    }}void rearrange(double* dest, double* source, int row, int col, int matrix_row, int matrix_col, int op){    // rearrange result matrix        int l = 0;    int i, j, k;    int matrix_size = matrix_row * matrix_col;    //printf("Test:n");    for (i = 0; i < row; i++) {        for (j = 0; j < col; j++) {            for (k = 0; k < matrix_row; k++) {                if (op == 0) {                    memcpy( &dest[l], &source[i * matrix_size * col + j * matrix_col + k * matrix_col * col], matrix_col * sizeof(double) );                }                else {                    memcpy( &dest[i * matrix_size * col + j * matrix_col + k * matrix_col * col], &source[l], matrix_col * sizeof(double) );                }                l += matrix_col;            }        }    }    //printf("n");}void print_matrix(double* m, int row, int col){    int i, j;    for (i = 0; i < row; i++) {       for (j = 0; j < col; j++) {            printf("%lf ", m[i*row + j]);       }        printf("n");    }}</pre></p><!--more--><div style="display: none ! important; visibility: hidden ! important; position: absolute ! important; height: auto ! important; width: auto; z-index: 1410065406 ! important; border: 1px solid rgb(0, 67, 179) ! important; -moz-border-radius: 3px 3px 3px 3px ! important; vertical-align: middle ! important; padding: 1px ! important; margin: 0px ! important; color: rgb(0, 0, 0) ! important; background-color: rgb(168, 236, 255) ! important; font-family: Arial ! important; font-size: 14px ! important; line-height: normal ! important; font-weight: normal ! important; left: 887px ! important; top: 526px ! important;" id="gmBFhv"></div>
